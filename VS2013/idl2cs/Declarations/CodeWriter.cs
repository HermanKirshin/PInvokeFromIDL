using idl2cs.TypeLib;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Serialization;

namespace idl2cs.Declarations
{
    public class CodeWriter : TextBlock
    {
        public CodeWriter(LibDesc assembly, Settings config)
            : base(0)
        {
            AccessModifierType accessModifier = config.Internal ? AccessModifierType.Internal : AccessModifierType.Public;

            config.SuppressedTypes.Add(new Settings.Type { Name = "IntPtr" });
            config.SuppressedTypes.Add(new Settings.Type { Name = "Guid" });

            var allTypes = assembly.Types.Where(x => !x.AutoGeneratedName && !config.SuppressedTypes.Any(y => y.Name == x.Name)).ToArray();

            WriteBaseLine(() => "using System;");
            WriteBaseLine(() => "using System.Collections.Concurrent;");
            WriteBaseLine(() => "using System.Runtime.InteropServices;");
            for(int i = 1; i < config.Namespaces.Count; i++)
                WriteBaseLine(() => "using " + config.Namespaces[i] + ";");
            WriteLine();
            WriteBaseLine(() => "namespace " + (config.Namespaces.Any() ? config.Namespaces.First().Name : assembly.Name));
            WriteBaseLine(() => "{");

            List<BaseTypeDeclaration> typeDeclarations = new List<BaseTypeDeclaration>();

            typeDeclarations.AddRange(allTypes.Where(x => (x.Kind == TypeKind.Interface) && InterfaceDeclaration.IsDelegate(x)).OrderBy(x => x.Name).Select(x => new DelegateDeclaration(x, this, accessModifier)));
            typeDeclarations.AddRange(allTypes.Where(x => x.Kind == TypeKind.Enum).OrderBy(x => x.Name).Select(x => new EnumDeclaration(x, this, accessModifier)));
            typeDeclarations.AddRange(allTypes.Where(x => (x.Kind == TypeKind.Struct) || (x.Kind == TypeKind.Union)).OrderBy(x => x.Name).Select(x => new StructDeclaration(x, this, accessModifier)));
            typeDeclarations.AddRange(allTypes.Where(x => x.Kind == TypeKind.Interface).Where(x => !InterfaceDeclaration.IsSpecialInterface(x)).OrderBy(x => x.Name).Select(x => new InterfaceDeclaration(x, this, accessModifier)));
            typeDeclarations.AddRange(allTypes.Where(x => x.Kind == TypeKind.Interface).Where(x => !InterfaceDeclaration.IsSpecialInterface(x) && !InterfaceDeclaration.IsUserImplemented(x)).OrderBy(x => x.Name).Select(x => new InterfaceWrapperDeclaration(x, this, accessModifier)));
            typeDeclarations.AddRange(allTypes.Where(x => (x.Kind == TypeKind.Interface) && InterfaceDeclaration.IsDelegate(x)).OrderBy(x => x.Name).Select(x => new DelegateWrapperDeclaration(x, this, accessModifier)));
            typeDeclarations.Add(new NativeMethodsDeclaration(allTypes.Where(x => x.Kind == TypeKind.Class), this, accessModifier));
            typeDeclarations.Add(new NativeConstantsDeclaration(allTypes.Where(x => x.Kind == TypeKind.Class), this, accessModifier));

            for (int i = 0; i < typeDeclarations.Count; i++)
            {
                AddTextBlock(typeDeclarations[i]);
                if (i != (typeDeclarations.Count - 1))
                    WriteLine();
            }
            
            WriteBaseLine(() => "}");
        }

        public static string GenerateCode(string library, Settings config)
        {
            using (LibDesc assembly = new LibDesc(library))
            {
                return new CodeWriter(assembly, config).GetString();
            }
        }
    }
}
