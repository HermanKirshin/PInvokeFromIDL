using idl2cs.TypeLib;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;

namespace idl2cs.TypeLib
{
    public enum TypeKind
    {
        Struct,
        Union,
        Enum,
        Interface,
        Class,
        System
    }

    public unsafe class TypeDesc
    {
        private ITypeInfo2 typeInfo;
        private TYPEATTR typeAttr;
        private Func<ITypeInfo2, uint, TypeDesc> typeFactory;

        public IEnumerable<TypeDesc> BaseTypes
        {
            get
            {
                return AllBaseTypes.Where(x => x != this);
            }
        }

        private IEnumerable<TypeDesc> AllBaseTypes
        {
            get
            {
                if (typeInfo != null)
                {
                    yield return this;
                    foreach (var currentDirectType in DirectBaseTypes)
                    {
                        foreach (var currentType in currentDirectType.AllBaseTypes)
                            yield return currentType;
                    }
                }
            }
        }

        public IEnumerable<TypeDesc> DirectBaseTypes
        {
            get
            {
                if (typeInfo != null)
                {
                    for (uint i = 0; i < typeAttr.cImplTypes; i++)
                    {
                        uint reftype;
                        typeInfo.GetRefTypeOfImplType(i, out reftype);
                        yield return GetReferencedType(reftype);
                    }
                }
            }
        }

        public IEnumerable<MethodDesc> Methods
        {
            get
            {
                if (typeInfo != null)
                {
                    for (uint i = 0; i < typeAttr.cFuncs; i++)
                        yield return CreateMethodDesc(i);
                }
            }
        }

        public IEnumerable<ParameterDesc> Fields
        {
            get
            {
                if (typeInfo != null)
                {
                    for (uint i = 0; i < typeAttr.cVars; i++)
                        yield return CreateFieldDesc(i);
                }
            }
        }

        public IEnumerable<MethodDesc> AllMethods
        {
            get
            {
                List<MethodDesc> result = new List<MethodDesc>();
                foreach (TypeDesc type in DirectBaseTypes)
                    result.AddRange(type.AllMethods);
                result.AddRange(Methods);
                return result.AsReadOnly();
            }
        }

        public string Name
        {
            get;
            private set;
        }

        public Guid CLSID
        {
            get
            {
                if (typeInfo == null)
                    return Guid.Empty;

                return typeAttr.guid;
            }
        }

        private TypeKind? kind;
        public TypeKind Kind
        {
            get
            {
                if (kind.HasValue)
                    return kind.Value;

                switch (typeAttr.typekind)
                {
                    case TYPEKIND.TKIND_RECORD:
                        return TypeKind.Struct;
                    case TYPEKIND.TKIND_UNION:
                        return TypeKind.Union;
                    case TYPEKIND.TKIND_ENUM:
                        return TypeKind.Enum;
                    case TYPEKIND.TKIND_COCLASS:
                    case TYPEKIND.TKIND_INTERFACE:
                    case TYPEKIND.TKIND_DISPATCH:
                        return TypeKind.Interface;
                    case TYPEKIND.TKIND_MODULE:
                        return TypeKind.Class;
                    default:
                        throw new Exception("Type kind " + typeAttr.typekind + " is not supported.");
                }
            }
        }

        public bool AutoGeneratedName
        {
            get
            {
                return Name.StartsWith("__MIDL__");
            }
        }

        public bool Pack1
        {
            get
            {
                return (typeInfo == null) || (typeAttr.cbAlignment == 1);
            }
        }

        public TypeDesc(string systemTypeName, TypeKind kind = TypeKind.System)
        {
            Name = systemTypeName;
            this.kind = kind;
        }

        public TypeDesc(ITypeInfo2 typeInfo, Func<ITypeInfo2, uint, TypeDesc> typeFactory, Func<ITypeInfo2, uint, ITypeInfo2> typeInfoFactory)
        {
            this.typeInfo = typeInfo;
            this.typeFactory = typeFactory;
            
            char* name = null;
            char* docString = null;
            char* helpFile = null;
            try
            {
                uint i1;
                typeInfo.GetDocumentation(NativeConstants.MEMBERID_NIL, out name, out docString, out i1, out helpFile);
                Name = new string(name);
                Name = EscapeTypeName(Name);
            }
            finally
            {
                if (name != null)
                    NativeMethods.SysFreeString(name);
                if (docString != null)
                    NativeMethods.SysFreeString(docString);
                if (helpFile != null)
                    NativeMethods.SysFreeString(helpFile);
            }

            InitTypeAttr();

            if (this.typeAttr.typekind == TYPEKIND.TKIND_ALIAS)
            {
                switch (this.typeAttr.tdescAlias.vt & VARENUM.VT_TYPEMASK)
                {
                    case VARENUM.VT_SAFEARRAY:
                    case VARENUM.VT_VARIANT:
                        kind = TypeKind.Struct;
                        break;
                    case VARENUM.VT_UNKNOWN:
                    case VARENUM.VT_DISPATCH:
                        kind = TypeKind.Interface;
                        break;
                    case VARENUM.VT_ERROR:
                    case VARENUM.VT_HRESULT:
                    case VARENUM.VT_LPSTR:
                    case VARENUM.VT_BSTR:
                    case VARENUM.VT_LPWSTR:
                    case VARENUM.VT_NULL:
                    case VARENUM.VT_BOOL:
                    case VARENUM.VT_I1:
                    case VARENUM.VT_I2:
                    case VARENUM.VT_I4:
                    case VARENUM.VT_INT:
                    case VARENUM.VT_I8:
                    case VARENUM.VT_FILETIME:
                    case VARENUM.VT_CY:
                    case VARENUM.VT_UI1:
                    case VARENUM.VT_UI2:
                    case VARENUM.VT_UI4:
                    case VARENUM.VT_UINT:
                    case VARENUM.VT_UI8:
                    case VARENUM.VT_R4:
                    case VARENUM.VT_R8:
                    case VARENUM.VT_DATE:
                    case VARENUM.VT_DECIMAL:
                    case VARENUM.VT_VOID:
                    case VARENUM.VT_INT_PTR:
                    case VARENUM.VT_UINT_PTR:
                        kind = TypeKind.System;
                        break;
                    case VARENUM.VT_USERDEFINED:
                        this.typeInfo = typeInfoFactory(typeInfo, this.typeAttr.tdescAlias.__union1.hreftype);
                        InitTypeAttr();
                        break;
                    default:
                        throw new Exception("Variant type " + this.typeAttr.tdescAlias.vt + " is not supported");
                }
            }
        }

        private void InitTypeAttr()
        {
            TYPEATTR* typeAttr = null;
            try
            {
                typeInfo.GetTypeAttr(out typeAttr);
                this.typeAttr = *typeAttr;
            }
            finally
            {
                if (typeAttr != null)
                    typeInfo.ReleaseTypeAttr(typeAttr);
            }
        }

        private ParameterDesc CreateFieldDesc(uint index)
        {
            if (typeInfo == null)
                throw new ObjectDisposedException(Name);

            VARDESC* vardesc = null;
            char** stringArray = stackalloc char*[1024];
            uint numArgumentNames = 0;
            try
            {
                typeInfo.GetVarDesc(index, out vardesc);

                typeInfo.GetNames(vardesc->memid, stringArray, 1024, out numArgumentNames);

                object value = null;
                bool hasValue = false;
                switch (vardesc->varkind)
                {
                    case VARKIND.VAR_CONST:
                        IntPtr valueAddress = new IntPtr(vardesc->__union1.lpvarValue);
                        if (valueAddress == null)
                            throw new Exception("Value address is null");
                        value = Marshal.GetObjectForNativeVariant(valueAddress);
                        hasValue = true;
                        break;
                    case VARKIND.VAR_PERINSTANCE:
                        //offset = (int)vardesc->__union1.oInst;
                        break;
                    default:
                        throw new Exception("Variable kind " + vardesc->varkind + " is not supported");
                }

                return new ParameterDesc(vardesc->elemdescVar, new string(stringArray[0]), GetReferencedType, (VARFLAGS)vardesc->wVarFlags, hasValue, value);
            }
            finally
            {
                if (vardesc != null)
                    typeInfo.ReleaseVarDesc(vardesc);
                for (int j = 0; j < numArgumentNames; j++)
                    NativeMethods.SysFreeString(stringArray[j]);
            }
        }

        private TypeDesc GetReferencedType(uint reference)
        {
            return typeFactory(typeInfo, reference);
        }

        private MethodDesc CreateMethodDesc(uint index)
        {
            if (typeInfo == null)
                throw new ObjectDisposedException(Name);

            FUNCDESC* funcDesc = null;
            char* dllPtr = null;
            char* entryPointPtr = null;
            char** stringArray = stackalloc char*[1024];
            uint numArgumentNames = 0;
            try
            {
                typeInfo.GetFuncDesc(index, out funcDesc);

                string dll = null;
                string entryPoint = null;
                if (typeAttr.typekind == TYPEKIND.TKIND_MODULE)
                {
                    ushort ordinal;
                    typeInfo.GetDllEntry(funcDesc->memid, INVOKEKIND.INVOKE_FUNC, out dllPtr, out entryPointPtr, out ordinal);
                    dll = new string(dllPtr);
                    if (entryPointPtr != null)
                        entryPoint = new string(entryPointPtr);
                    else
                        entryPoint = "#" + ordinal.ToString(CultureInfo.InvariantCulture);
                }

                typeInfo.GetNames(funcDesc->memid, stringArray, 1024, out numArgumentNames);

                List<string> argumentNames = new List<string>();
                for (uint j = 1; j < numArgumentNames; j++)
                    argumentNames.Add(new string(stringArray[j]));

                return new MethodDesc(new string(stringArray[0]), dll, entryPoint, *funcDesc, argumentNames.ToArray(), GetReferencedType);
            }
            finally
            {
                if (funcDesc != null)
                    typeInfo.ReleaseFuncDesc(funcDesc);
                if (dllPtr != null)
                    NativeMethods.SysFreeString(dllPtr);
                if (entryPointPtr != null)
                    NativeMethods.SysFreeString(entryPointPtr);
                for (int j = 0; j < numArgumentNames; j++)
                    NativeMethods.SysFreeString(stringArray[j]);
            }
        }

        private static string EscapeTypeName(string name)
        {
            switch (name)
            {
                case "abstract":
                case "as":
                case "base":
                case "break":
                case "case":
                case "catch":
                case "checked":
                case "class":
                case "const":
                case "continue":
                case "default":
                case "delegate":
                case "do":
                case "else":
                case "enum":
                case "event":
                case "explicit":
                case "extern":
                case "false":
                case "finally":
                case "fixed":
                case "for":
                case "foreach":
                case "goto":
                case "if":
                case "implicit":
                case "in":
                case "interface":
                case "internal":
                case "is":
                case "lock":
                case "namespace":
                case "new":
                case "null":
                case "operator":
                case "out":
                case "override":
                case "params":
                case "private":
                case "protected":
                case "public":
                case "readonly":
                case "ref":
                case "return":
                case "sealed":
                case "sizeof":
                case "stackalloc":
                case "static":
                case "struct":
                case "switch":
                case "this":
                case "throw":
                case "true":
                case "try":
                case "typeof":
                case "unchecked":
                case "unsafe":
                case "using":
                case "virtual":
                case "volatile":
                case "while":
                case "add":
                case "alias":
                case "ascending":
                case "async":
                case "await":
                case "descending":
                case "dynamic":
                case "from":
                case "get":
                case "global":
                case "group":
                case "into":
                case "join":
                case "let":
                case "orderby":
                case "partial":
                case "remove":
                case "select":
                case "set":
                case "value":
                case "var":
                case "where":
                case "yield ":
                    return "@" + name;
                default:
                    return name;
            }
        }
    }
}
