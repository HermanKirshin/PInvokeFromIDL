using idl2cs.TypeLib;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace idl2cs.Declarations
{
    public class StructDeclaration : BaseTypeDeclaration
    {
        protected override string DeclarationType
        {
            get
            {
                return "unsafe struct";
            }
        }

        protected override IEnumerable<string> Attributes
        {
            get
            {
                //yield return "[Serializable]";
                if (Type.Kind == TypeKind.Union)
                    yield return "[StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode" + (Type.Pack1 ? ", Pack = 1" : "") + ")]"; 
                else
                    yield return "[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode" + (Type.Pack1 ? ", Pack = 1" : "") + ")]";
            }
        }

        protected override IEnumerable<string> BaseTypes
        {
            get
            {
                return new string[0];
            }
        }

        public StructDeclaration(TypeDesc type, TextBlock container, AccessModifierType accessModifier)
            : this(type, container, accessModifier, true)
        {
        }

        private StructDeclaration(TypeDesc type, TextBlock container, AccessModifierType accessModifier, bool root)
            : base(type, container, accessModifier)
        {
            if (type.BaseTypes.Any())
                throw new Exception("Base types are not expected for struct");
            if (type.Methods.Any())
                throw new Exception("Methods are not expected for struct");

            TypeDesc bitField = CheckBitField(Type);

            var fields = type.Fields.ToArray();

            WriteBaseLine(() => "{");
           
            if (bitField == null)
            {
                if (root)
                {
                    Action<TypeDesc, List<TypeDesc>, List<ParameterDesc>> getNestedTypes = null;
                    getNestedTypes = (currentType, types, parameters) =>
                    {
                        if (!types.Any(x => x.Name == currentType.Name))
                        {
                            types.Add(currentType);
                            parameters.AddRange(currentType.Fields);
                            if (CheckBitField(currentType) == null)
                                currentType.Fields.ToList().ForEach(x => getNestedTypes(x.Type, types, parameters));
                        }
                    };

                    List<TypeDesc> nestedTypeDescList = new List<TypeDesc>();
                    List<ParameterDesc> parameterDescList = new List<ParameterDesc>();
                    getNestedTypes(type, nestedTypeDescList, parameterDescList);

                    List<BaseTypeDeclaration> nestedTypes = new List<BaseTypeDeclaration>();

                    nestedTypes.AddRange(nestedTypeDescList.Where(x => x.AutoGeneratedName).Select(x => (BaseTypeDeclaration)new StructDeclaration(x, this, accessModifier, false)));
                    nestedTypes.AddRange(parameterDescList.Where(x => x.ArraySizes.Any()).Select(x => (BaseTypeDeclaration)new ArrayWrapperDeclararation(x, this, accessModifier)).Where(x => !nestedTypes.Any(y => y.TypeName == x.TypeName)));

                    nestedTypes.ForEach(x =>
                    {
                        AddTextBlock(x);
                        WriteLine();
                    });
                }

                Action<List<ParameterDesc>> processNamelessField = null;
                processNamelessField = list =>
                {
                    ParameterDesc currentParameter = list[list.Count - 1];
                    if (currentParameter.AutoGeneratedName)
                    {
                        foreach (var item in currentParameter.Type.Fields.ToArray())
                            processNamelessField(list.Union(new ParameterDesc[] { item }).ToList());
                    }
                    else
                    {
                        if (!currentParameter.Hidden)
                        {
                            string propertyType = currentParameter.TypeDeclaration;
                            if (currentParameter.ArraySizes.Any() && !currentParameter.SpecialFlag)
                                propertyType = new ArrayWrapperDeclararation(currentParameter, this, accessModifier).TypeName;

                            WriteLine();
                            WriteLine(() => AccessModifier + " " + propertyType + " " + currentParameter.Name);
                            WriteLine(() => "{");
                            WriteLine(() => "    get");
                            WriteLine(() => "    {");
                            WriteLine(() => "        return " + string.Join(".", list.Select(x => x.Name)) + ";");
                            WriteLine(() => "    }");
                            WriteLine(() => "    set");
                            WriteLine(() => "    {");
                            WriteLine(() => "        " + string.Join(".", list.Select(x => x.Name)) + " = value;");
                            WriteLine(() => "    }");
                            WriteLine(() => "}");
                        }
                    }
                };

                for (int i = 0; i < fields.Length; i++)
                {
                    ParameterDesc field = fields[i];

                    if (type.Kind == TypeKind.Union)
                        WriteLine(() => "[FieldOffset(0)]");

                    AddTextBlock(new FieldDeclaration(field, this, AccessModifier));
                }

                foreach (var field in type.Fields.Where(x => x.AutoGeneratedName))
                    processNamelessField(new ParameterDesc[] { field }.ToList());
            }
            else
            {
                AddTextBlock(new FieldDeclaration(bitField, "__bit_field_value", this, AccessModifierType.Private));

                int bitFieldOffset = 0;
                for (int i = 0; i < fields.Length; i++)
                {
                    ParameterDesc field = fields[i];
                    int bitFieldSize = field.ArraySizes.Single();
                    int bitFieldMask = 0;
                    for (int j = 0; j < bitFieldSize; j++)
                        bitFieldMask |= (1 << j);

                    WriteLine();
                    WriteLine(() => AccessModifier + " " + bitField.Name + " " + field.Name);
                    WriteLine(() => "{");
                    WriteLine(() => "    get");
                    WriteLine(() => "    {");
                    WriteLine(() => "        return (" + bitField.Name + ")((__bit_field_value >> " + bitFieldOffset.ToString() + ") & " + bitFieldMask.ToString() + ");");
                    WriteLine(() => "    }");
                    WriteLine(() => "    set");
                    WriteLine(() => "    {");
                    WriteLine(() => "        __bit_field_value = (" + bitField.Name + ")((value & " + bitFieldMask.ToString() + ") << " + bitFieldOffset.ToString() + ");");
                    WriteLine(() => "    }");
                    WriteLine(() => "}");

                    bitFieldOffset += bitFieldSize;
                }
            }

            WriteLine();
            WriteLine(() => AccessModifier + " unsafe static int GetSize()");
            WriteLine(() => "{");
            WriteLine(() => "    return Marshal.SizeOf(typeof(" + TypeName + "));");
            WriteLine(() => "}");

            if ((TypeName == "BOOL") || (TypeName == "BOOLEAN"))
            {
                WriteLine();
                WriteLine(() => "public static unsafe implicit operator bool(" + TypeName + " value)");
                WriteLine(() => "{");
                WriteLine(() => "    return (value.Value != 0);");
                WriteLine(() => "}");
                WriteLine();
                WriteLine(() => "public static unsafe implicit operator " + TypeName + "(bool value)");
                WriteLine(() => "{");
                WriteLine(() => "    return new " + TypeName + " { Value = (byte)(value ? 1 : 0) };");
                WriteLine(() => "}");
            }

            WriteLine();
            WriteLine(() => "public unsafe override bool Equals(object obj)");
            WriteLine(() => "{");
            WriteLine(() => "    if (!(obj is " + TypeName + "))");
            WriteLine(() => "        return false;");
            WriteLine(() => "    fixed (" + TypeName + "* address = &this)");
            WriteLine(() => "    {");
            WriteLine(() => "        " + TypeName + " other = (" + TypeName + ")obj;");
            WriteLine(() => "        IntPtr size = new IntPtr(GetSize());");
            WriteLine(() => "        IntPtr equalBytes = NativeMethods.RtlCompareMemory(address, &other, size);");
            WriteLine(() => "        return size == equalBytes;");
            WriteLine(() => "    }");
            WriteLine(() => "}");
            WriteLine();
            WriteLine(() => "public unsafe override int GetHashCode()");
            WriteLine(() => "{");
            WriteLine(() => "    int result = 0;");
            WriteLine(() => "    int size = GetSize();");
            WriteLine(() => "    fixed (" + TypeName + "* address = &this)");
            WriteLine(() => "    {");
            WriteLine(() => "        byte* byteAddress = (byte*)address;");
            WriteLine(() => "        for (int i = 0; i < size; i++)");
            WriteLine(() => "            result ^= byteAddress[i] << i;");
            WriteLine(() => "    }");
            WriteLine(() => "    return result;");
            WriteLine(() => "}");
            WriteLine();
            WriteLine(() => "public unsafe static bool operator ==(" + TypeName + " left, " + TypeName + " right)");
            WriteLine(() => "{");
            WriteLine(() => "    IntPtr size = new IntPtr(GetSize());");
            WriteLine(() => "    IntPtr equalBytes = NativeMethods.RtlCompareMemory(&left, &right, size);");
            WriteLine(() => "    return size == equalBytes;");
            WriteLine(() => "}");
            WriteLine();
            WriteLine(() => "public unsafe static bool operator !=(" + TypeName + " left, " + TypeName + " right)");
            WriteLine(() => "{");
            WriteLine(() => "    IntPtr size = new IntPtr(GetSize());");
            WriteLine(() => "    IntPtr equalBytes = NativeMethods.RtlCompareMemory(&left, &right, size);");
            WriteLine(() => "    return size != equalBytes;");
            WriteLine(() => "}");

            WriteBaseLine(() => "}");
        }

        private static TypeDesc CheckBitField(TypeDesc type)
        {
            if (!type.Fields.Any(x => x.SpecialFlag))
                return null;

            if (!type.Fields.All(x => x.SpecialFlag))
                throw new Exception("All bit fields should be marked with special flag");
            if (type.Fields.Select(x => x.Type.Name).Distinct().Count() > 1)
                throw new Exception("All bit fields should have the same type");
            if (type.Fields.Any(x => x.IndirectionLevel > 0))
                throw new Exception("Bit fields cannot be pointer type");
            if (!type.Fields.All(x => x.ArraySizes.Count == 1))
                throw new Exception("To specify size bit fields should be declared as arrays");

            string fieldType = type.Fields.Select(x => x.Type.Name).Distinct().Single();

            int sizeInBits;
            switch (fieldType)
            {
                case "byte":
                case "sbyte":
                    sizeInBits = 8;
                    break;
                case "short":
                case "ushort":
                    sizeInBits = 16;
                    break;
                case "int":
                case "uint":
                    sizeInBits = 32;
                    break;
                case "long":
                case "ulong":
                    sizeInBits = 64;
                    break;
                default:
                    throw new Exception("Bit fields cannot be of type " + fieldType);
            }

            if (type.Fields.Select(x => x.ArraySizes.Single()).Sum() > sizeInBits)
                throw new Exception("Total size of bit field cannot be greater than underlying type");

            return new TypeDesc(fieldType);
        }
    }
}
